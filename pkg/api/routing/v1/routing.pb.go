// Routing API for Pingora Gateway Controller
//
// This API defines the contract between the Kubernetes controller (Go)
// and the Pingora proxy (Rust) for dynamic route updates.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: routing/v1/routing.proto

package routingv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// PathMatchType defines the type of path matching.
type PathMatchType int32

const (
	PathMatchType_PATH_MATCH_TYPE_UNSPECIFIED PathMatchType = 0
	PathMatchType_PATH_MATCH_TYPE_EXACT       PathMatchType = 1
	PathMatchType_PATH_MATCH_TYPE_PREFIX      PathMatchType = 2
	PathMatchType_PATH_MATCH_TYPE_REGEX       PathMatchType = 3
)

// Enum value maps for PathMatchType.
var (
	PathMatchType_name = map[int32]string{
		0: "PATH_MATCH_TYPE_UNSPECIFIED",
		1: "PATH_MATCH_TYPE_EXACT",
		2: "PATH_MATCH_TYPE_PREFIX",
		3: "PATH_MATCH_TYPE_REGEX",
	}
	PathMatchType_value = map[string]int32{
		"PATH_MATCH_TYPE_UNSPECIFIED": 0,
		"PATH_MATCH_TYPE_EXACT":       1,
		"PATH_MATCH_TYPE_PREFIX":      2,
		"PATH_MATCH_TYPE_REGEX":       3,
	}
)

func (x PathMatchType) Enum() *PathMatchType {
	p := new(PathMatchType)
	*p = x
	return p
}

func (x PathMatchType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PathMatchType) Descriptor() protoreflect.EnumDescriptor {
	return file_routing_v1_routing_proto_enumTypes[0].Descriptor()
}

func (PathMatchType) Type() protoreflect.EnumType {
	return &file_routing_v1_routing_proto_enumTypes[0]
}

func (x PathMatchType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PathMatchType.Descriptor instead.
func (PathMatchType) EnumDescriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{0}
}

// HeaderMatchType defines the type of header matching.
type HeaderMatchType int32

const (
	HeaderMatchType_HEADER_MATCH_TYPE_UNSPECIFIED HeaderMatchType = 0
	HeaderMatchType_HEADER_MATCH_TYPE_EXACT       HeaderMatchType = 1
	HeaderMatchType_HEADER_MATCH_TYPE_REGEX       HeaderMatchType = 2
)

// Enum value maps for HeaderMatchType.
var (
	HeaderMatchType_name = map[int32]string{
		0: "HEADER_MATCH_TYPE_UNSPECIFIED",
		1: "HEADER_MATCH_TYPE_EXACT",
		2: "HEADER_MATCH_TYPE_REGEX",
	}
	HeaderMatchType_value = map[string]int32{
		"HEADER_MATCH_TYPE_UNSPECIFIED": 0,
		"HEADER_MATCH_TYPE_EXACT":       1,
		"HEADER_MATCH_TYPE_REGEX":       2,
	}
)

func (x HeaderMatchType) Enum() *HeaderMatchType {
	p := new(HeaderMatchType)
	*p = x
	return p
}

func (x HeaderMatchType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HeaderMatchType) Descriptor() protoreflect.EnumDescriptor {
	return file_routing_v1_routing_proto_enumTypes[1].Descriptor()
}

func (HeaderMatchType) Type() protoreflect.EnumType {
	return &file_routing_v1_routing_proto_enumTypes[1]
}

func (x HeaderMatchType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HeaderMatchType.Descriptor instead.
func (HeaderMatchType) EnumDescriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{1}
}

// QueryParamMatchType defines the type of query parameter matching.
type QueryParamMatchType int32

const (
	QueryParamMatchType_QUERY_PARAM_MATCH_TYPE_UNSPECIFIED QueryParamMatchType = 0
	QueryParamMatchType_QUERY_PARAM_MATCH_TYPE_EXACT       QueryParamMatchType = 1
	QueryParamMatchType_QUERY_PARAM_MATCH_TYPE_REGEX       QueryParamMatchType = 2
)

// Enum value maps for QueryParamMatchType.
var (
	QueryParamMatchType_name = map[int32]string{
		0: "QUERY_PARAM_MATCH_TYPE_UNSPECIFIED",
		1: "QUERY_PARAM_MATCH_TYPE_EXACT",
		2: "QUERY_PARAM_MATCH_TYPE_REGEX",
	}
	QueryParamMatchType_value = map[string]int32{
		"QUERY_PARAM_MATCH_TYPE_UNSPECIFIED": 0,
		"QUERY_PARAM_MATCH_TYPE_EXACT":       1,
		"QUERY_PARAM_MATCH_TYPE_REGEX":       2,
	}
)

func (x QueryParamMatchType) Enum() *QueryParamMatchType {
	p := new(QueryParamMatchType)
	*p = x
	return p
}

func (x QueryParamMatchType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (QueryParamMatchType) Descriptor() protoreflect.EnumDescriptor {
	return file_routing_v1_routing_proto_enumTypes[2].Descriptor()
}

func (QueryParamMatchType) Type() protoreflect.EnumType {
	return &file_routing_v1_routing_proto_enumTypes[2]
}

func (x QueryParamMatchType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use QueryParamMatchType.Descriptor instead.
func (QueryParamMatchType) EnumDescriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{2}
}

// GRPCMethodMatchType defines the type of gRPC method matching.
type GRPCMethodMatchType int32

const (
	GRPCMethodMatchType_GRPC_METHOD_MATCH_TYPE_UNSPECIFIED GRPCMethodMatchType = 0
	GRPCMethodMatchType_GRPC_METHOD_MATCH_TYPE_EXACT       GRPCMethodMatchType = 1
	GRPCMethodMatchType_GRPC_METHOD_MATCH_TYPE_REGEX       GRPCMethodMatchType = 2
)

// Enum value maps for GRPCMethodMatchType.
var (
	GRPCMethodMatchType_name = map[int32]string{
		0: "GRPC_METHOD_MATCH_TYPE_UNSPECIFIED",
		1: "GRPC_METHOD_MATCH_TYPE_EXACT",
		2: "GRPC_METHOD_MATCH_TYPE_REGEX",
	}
	GRPCMethodMatchType_value = map[string]int32{
		"GRPC_METHOD_MATCH_TYPE_UNSPECIFIED": 0,
		"GRPC_METHOD_MATCH_TYPE_EXACT":       1,
		"GRPC_METHOD_MATCH_TYPE_REGEX":       2,
	}
)

func (x GRPCMethodMatchType) Enum() *GRPCMethodMatchType {
	p := new(GRPCMethodMatchType)
	*p = x
	return p
}

func (x GRPCMethodMatchType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GRPCMethodMatchType) Descriptor() protoreflect.EnumDescriptor {
	return file_routing_v1_routing_proto_enumTypes[3].Descriptor()
}

func (GRPCMethodMatchType) Type() protoreflect.EnumType {
	return &file_routing_v1_routing_proto_enumTypes[3]
}

func (x GRPCMethodMatchType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GRPCMethodMatchType.Descriptor instead.
func (GRPCMethodMatchType) EnumDescriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{3}
}

// BackendProtocol defines the protocol for backend connections.
type BackendProtocol int32

const (
	BackendProtocol_BACKEND_PROTOCOL_UNSPECIFIED BackendProtocol = 0
	BackendProtocol_BACKEND_PROTOCOL_HTTP        BackendProtocol = 1
	BackendProtocol_BACKEND_PROTOCOL_HTTPS       BackendProtocol = 2
	BackendProtocol_BACKEND_PROTOCOL_H2C         BackendProtocol = 3
	BackendProtocol_BACKEND_PROTOCOL_H2          BackendProtocol = 4
)

// Enum value maps for BackendProtocol.
var (
	BackendProtocol_name = map[int32]string{
		0: "BACKEND_PROTOCOL_UNSPECIFIED",
		1: "BACKEND_PROTOCOL_HTTP",
		2: "BACKEND_PROTOCOL_HTTPS",
		3: "BACKEND_PROTOCOL_H2C",
		4: "BACKEND_PROTOCOL_H2",
	}
	BackendProtocol_value = map[string]int32{
		"BACKEND_PROTOCOL_UNSPECIFIED": 0,
		"BACKEND_PROTOCOL_HTTP":        1,
		"BACKEND_PROTOCOL_HTTPS":       2,
		"BACKEND_PROTOCOL_H2C":         3,
		"BACKEND_PROTOCOL_H2":          4,
	}
)

func (x BackendProtocol) Enum() *BackendProtocol {
	p := new(BackendProtocol)
	*p = x
	return p
}

func (x BackendProtocol) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BackendProtocol) Descriptor() protoreflect.EnumDescriptor {
	return file_routing_v1_routing_proto_enumTypes[4].Descriptor()
}

func (BackendProtocol) Type() protoreflect.EnumType {
	return &file_routing_v1_routing_proto_enumTypes[4]
}

func (x BackendProtocol) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BackendProtocol.Descriptor instead.
func (BackendProtocol) EnumDescriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{4}
}

// UpdateRoutesRequest contains the complete routing configuration.
type UpdateRoutesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of all HTTP routes to configure.
	HttpRoutes []*HTTPRoute `protobuf:"bytes,1,rep,name=http_routes,json=httpRoutes,proto3" json:"http_routes,omitempty"`
	// List of all gRPC routes to configure.
	GrpcRoutes []*GRPCRoute `protobuf:"bytes,2,rep,name=grpc_routes,json=grpcRoutes,proto3" json:"grpc_routes,omitempty"`
	// Configuration version for tracking updates.
	// Monotonically increasing, used for optimistic concurrency.
	Version       uint64 `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateRoutesRequest) Reset() {
	*x = UpdateRoutesRequest{}
	mi := &file_routing_v1_routing_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateRoutesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateRoutesRequest) ProtoMessage() {}

func (x *UpdateRoutesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_routing_v1_routing_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateRoutesRequest.ProtoReflect.Descriptor instead.
func (*UpdateRoutesRequest) Descriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{0}
}

func (x *UpdateRoutesRequest) GetHttpRoutes() []*HTTPRoute {
	if x != nil {
		return x.HttpRoutes
	}
	return nil
}

func (x *UpdateRoutesRequest) GetGrpcRoutes() []*GRPCRoute {
	if x != nil {
		return x.GrpcRoutes
	}
	return nil
}

func (x *UpdateRoutesRequest) GetVersion() uint64 {
	if x != nil {
		return x.Version
	}
	return 0
}

// UpdateRoutesResponse confirms the route update.
type UpdateRoutesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether the update was successful.
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Error message if success is false.
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// The version that was applied.
	AppliedVersion uint64 `protobuf:"varint,3,opt,name=applied_version,json=appliedVersion,proto3" json:"applied_version,omitempty"`
	// Number of HTTP routes configured.
	HttpRouteCount uint32 `protobuf:"varint,4,opt,name=http_route_count,json=httpRouteCount,proto3" json:"http_route_count,omitempty"`
	// Number of gRPC routes configured.
	GrpcRouteCount uint32 `protobuf:"varint,5,opt,name=grpc_route_count,json=grpcRouteCount,proto3" json:"grpc_route_count,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *UpdateRoutesResponse) Reset() {
	*x = UpdateRoutesResponse{}
	mi := &file_routing_v1_routing_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateRoutesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateRoutesResponse) ProtoMessage() {}

func (x *UpdateRoutesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_routing_v1_routing_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateRoutesResponse.ProtoReflect.Descriptor instead.
func (*UpdateRoutesResponse) Descriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{1}
}

func (x *UpdateRoutesResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *UpdateRoutesResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *UpdateRoutesResponse) GetAppliedVersion() uint64 {
	if x != nil {
		return x.AppliedVersion
	}
	return 0
}

func (x *UpdateRoutesResponse) GetHttpRouteCount() uint32 {
	if x != nil {
		return x.HttpRouteCount
	}
	return 0
}

func (x *UpdateRoutesResponse) GetGrpcRouteCount() uint32 {
	if x != nil {
		return x.GrpcRouteCount
	}
	return 0
}

// GetRoutesRequest requests the current route configuration.
type GetRoutesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRoutesRequest) Reset() {
	*x = GetRoutesRequest{}
	mi := &file_routing_v1_routing_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRoutesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRoutesRequest) ProtoMessage() {}

func (x *GetRoutesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_routing_v1_routing_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRoutesRequest.ProtoReflect.Descriptor instead.
func (*GetRoutesRequest) Descriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{2}
}

// GetRoutesResponse returns the current route configuration.
type GetRoutesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of all HTTP routes.
	HttpRoutes []*HTTPRoute `protobuf:"bytes,1,rep,name=http_routes,json=httpRoutes,proto3" json:"http_routes,omitempty"`
	// List of all gRPC routes.
	GrpcRoutes []*GRPCRoute `protobuf:"bytes,2,rep,name=grpc_routes,json=grpcRoutes,proto3" json:"grpc_routes,omitempty"`
	// Current configuration version.
	Version       uint64 `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRoutesResponse) Reset() {
	*x = GetRoutesResponse{}
	mi := &file_routing_v1_routing_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRoutesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRoutesResponse) ProtoMessage() {}

func (x *GetRoutesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_routing_v1_routing_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRoutesResponse.ProtoReflect.Descriptor instead.
func (*GetRoutesResponse) Descriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{3}
}

func (x *GetRoutesResponse) GetHttpRoutes() []*HTTPRoute {
	if x != nil {
		return x.HttpRoutes
	}
	return nil
}

func (x *GetRoutesResponse) GetGrpcRoutes() []*GRPCRoute {
	if x != nil {
		return x.GrpcRoutes
	}
	return nil
}

func (x *GetRoutesResponse) GetVersion() uint64 {
	if x != nil {
		return x.Version
	}
	return 0
}

// HealthRequest requests health status.
type HealthRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealthRequest) Reset() {
	*x = HealthRequest{}
	mi := &file_routing_v1_routing_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthRequest) ProtoMessage() {}

func (x *HealthRequest) ProtoReflect() protoreflect.Message {
	mi := &file_routing_v1_routing_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthRequest.ProtoReflect.Descriptor instead.
func (*HealthRequest) Descriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{4}
}

// HealthResponse returns health status.
type HealthResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether the proxy is healthy.
	Healthy bool `protobuf:"varint,1,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Human-readable status message.
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// Number of active connections.
	ActiveConnections uint64 `protobuf:"varint,3,opt,name=active_connections,json=activeConnections,proto3" json:"active_connections,omitempty"`
	// Current configuration version.
	ConfigVersion uint64 `protobuf:"varint,4,opt,name=config_version,json=configVersion,proto3" json:"config_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealthResponse) Reset() {
	*x = HealthResponse{}
	mi := &file_routing_v1_routing_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthResponse) ProtoMessage() {}

func (x *HealthResponse) ProtoReflect() protoreflect.Message {
	mi := &file_routing_v1_routing_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthResponse.ProtoReflect.Descriptor instead.
func (*HealthResponse) Descriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{5}
}

func (x *HealthResponse) GetHealthy() bool {
	if x != nil {
		return x.Healthy
	}
	return false
}

func (x *HealthResponse) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *HealthResponse) GetActiveConnections() uint64 {
	if x != nil {
		return x.ActiveConnections
	}
	return 0
}

func (x *HealthResponse) GetConfigVersion() uint64 {
	if x != nil {
		return x.ConfigVersion
	}
	return 0
}

// HTTPRoute defines an HTTP routing rule.
type HTTPRoute struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier for this route (namespace/name).
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Hostnames this route matches.
	Hostnames []string `protobuf:"bytes,2,rep,name=hostnames,proto3" json:"hostnames,omitempty"`
	// Routing rules for this HTTPRoute.
	Rules         []*HTTPRouteRule `protobuf:"bytes,3,rep,name=rules,proto3" json:"rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HTTPRoute) Reset() {
	*x = HTTPRoute{}
	mi := &file_routing_v1_routing_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HTTPRoute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HTTPRoute) ProtoMessage() {}

func (x *HTTPRoute) ProtoReflect() protoreflect.Message {
	mi := &file_routing_v1_routing_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HTTPRoute.ProtoReflect.Descriptor instead.
func (*HTTPRoute) Descriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{6}
}

func (x *HTTPRoute) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *HTTPRoute) GetHostnames() []string {
	if x != nil {
		return x.Hostnames
	}
	return nil
}

func (x *HTTPRoute) GetRules() []*HTTPRouteRule {
	if x != nil {
		return x.Rules
	}
	return nil
}

// HTTPRouteRule defines a single HTTP routing rule.
type HTTPRouteRule struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Matchers for this rule.
	Matches []*HTTPRouteMatch `protobuf:"bytes,1,rep,name=matches,proto3" json:"matches,omitempty"`
	// Backend references for this rule.
	Backends []*Backend `protobuf:"bytes,2,rep,name=backends,proto3" json:"backends,omitempty"`
	// Request timeout in milliseconds.
	TimeoutMs uint64 `protobuf:"varint,3,opt,name=timeout_ms,json=timeoutMs,proto3" json:"timeout_ms,omitempty"`
	// Retry configuration.
	Retry         *RetryConfig `protobuf:"bytes,4,opt,name=retry,proto3" json:"retry,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HTTPRouteRule) Reset() {
	*x = HTTPRouteRule{}
	mi := &file_routing_v1_routing_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HTTPRouteRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HTTPRouteRule) ProtoMessage() {}

func (x *HTTPRouteRule) ProtoReflect() protoreflect.Message {
	mi := &file_routing_v1_routing_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HTTPRouteRule.ProtoReflect.Descriptor instead.
func (*HTTPRouteRule) Descriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{7}
}

func (x *HTTPRouteRule) GetMatches() []*HTTPRouteMatch {
	if x != nil {
		return x.Matches
	}
	return nil
}

func (x *HTTPRouteRule) GetBackends() []*Backend {
	if x != nil {
		return x.Backends
	}
	return nil
}

func (x *HTTPRouteRule) GetTimeoutMs() uint64 {
	if x != nil {
		return x.TimeoutMs
	}
	return 0
}

func (x *HTTPRouteRule) GetRetry() *RetryConfig {
	if x != nil {
		return x.Retry
	}
	return nil
}

// HTTPRouteMatch defines conditions for matching an HTTP request.
type HTTPRouteMatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Path match configuration.
	Path *PathMatch `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Header match conditions.
	Headers []*HeaderMatch `protobuf:"bytes,2,rep,name=headers,proto3" json:"headers,omitempty"`
	// Query parameter match conditions.
	QueryParams []*QueryParamMatch `protobuf:"bytes,3,rep,name=query_params,json=queryParams,proto3" json:"query_params,omitempty"`
	// HTTP method to match (GET, POST, etc.).
	Method        string `protobuf:"bytes,4,opt,name=method,proto3" json:"method,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HTTPRouteMatch) Reset() {
	*x = HTTPRouteMatch{}
	mi := &file_routing_v1_routing_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HTTPRouteMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HTTPRouteMatch) ProtoMessage() {}

func (x *HTTPRouteMatch) ProtoReflect() protoreflect.Message {
	mi := &file_routing_v1_routing_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HTTPRouteMatch.ProtoReflect.Descriptor instead.
func (*HTTPRouteMatch) Descriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{8}
}

func (x *HTTPRouteMatch) GetPath() *PathMatch {
	if x != nil {
		return x.Path
	}
	return nil
}

func (x *HTTPRouteMatch) GetHeaders() []*HeaderMatch {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *HTTPRouteMatch) GetQueryParams() []*QueryParamMatch {
	if x != nil {
		return x.QueryParams
	}
	return nil
}

func (x *HTTPRouteMatch) GetMethod() string {
	if x != nil {
		return x.Method
	}
	return ""
}

// PathMatch defines how to match the request path.
type PathMatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Type of path match.
	Type PathMatchType `protobuf:"varint,1,opt,name=type,proto3,enum=routing.v1.PathMatchType" json:"type,omitempty"`
	// Value to match against.
	Value         string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PathMatch) Reset() {
	*x = PathMatch{}
	mi := &file_routing_v1_routing_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PathMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PathMatch) ProtoMessage() {}

func (x *PathMatch) ProtoReflect() protoreflect.Message {
	mi := &file_routing_v1_routing_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PathMatch.ProtoReflect.Descriptor instead.
func (*PathMatch) Descriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{9}
}

func (x *PathMatch) GetType() PathMatchType {
	if x != nil {
		return x.Type
	}
	return PathMatchType_PATH_MATCH_TYPE_UNSPECIFIED
}

func (x *PathMatch) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

// HeaderMatch defines a header matching condition.
type HeaderMatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Header name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Header value to match.
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// Type of match.
	Type          HeaderMatchType `protobuf:"varint,3,opt,name=type,proto3,enum=routing.v1.HeaderMatchType" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeaderMatch) Reset() {
	*x = HeaderMatch{}
	mi := &file_routing_v1_routing_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeaderMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeaderMatch) ProtoMessage() {}

func (x *HeaderMatch) ProtoReflect() protoreflect.Message {
	mi := &file_routing_v1_routing_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeaderMatch.ProtoReflect.Descriptor instead.
func (*HeaderMatch) Descriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{10}
}

func (x *HeaderMatch) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *HeaderMatch) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *HeaderMatch) GetType() HeaderMatchType {
	if x != nil {
		return x.Type
	}
	return HeaderMatchType_HEADER_MATCH_TYPE_UNSPECIFIED
}

// QueryParamMatch defines a query parameter matching condition.
type QueryParamMatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Parameter name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Parameter value to match.
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// Type of match.
	Type          QueryParamMatchType `protobuf:"varint,3,opt,name=type,proto3,enum=routing.v1.QueryParamMatchType" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueryParamMatch) Reset() {
	*x = QueryParamMatch{}
	mi := &file_routing_v1_routing_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryParamMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryParamMatch) ProtoMessage() {}

func (x *QueryParamMatch) ProtoReflect() protoreflect.Message {
	mi := &file_routing_v1_routing_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryParamMatch.ProtoReflect.Descriptor instead.
func (*QueryParamMatch) Descriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{11}
}

func (x *QueryParamMatch) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *QueryParamMatch) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *QueryParamMatch) GetType() QueryParamMatchType {
	if x != nil {
		return x.Type
	}
	return QueryParamMatchType_QUERY_PARAM_MATCH_TYPE_UNSPECIFIED
}

// GRPCRoute defines a gRPC routing rule.
type GRPCRoute struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier for this route (namespace/name).
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Hostnames this route matches.
	Hostnames []string `protobuf:"bytes,2,rep,name=hostnames,proto3" json:"hostnames,omitempty"`
	// Routing rules for this GRPCRoute.
	Rules         []*GRPCRouteRule `protobuf:"bytes,3,rep,name=rules,proto3" json:"rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GRPCRoute) Reset() {
	*x = GRPCRoute{}
	mi := &file_routing_v1_routing_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GRPCRoute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GRPCRoute) ProtoMessage() {}

func (x *GRPCRoute) ProtoReflect() protoreflect.Message {
	mi := &file_routing_v1_routing_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GRPCRoute.ProtoReflect.Descriptor instead.
func (*GRPCRoute) Descriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{12}
}

func (x *GRPCRoute) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *GRPCRoute) GetHostnames() []string {
	if x != nil {
		return x.Hostnames
	}
	return nil
}

func (x *GRPCRoute) GetRules() []*GRPCRouteRule {
	if x != nil {
		return x.Rules
	}
	return nil
}

// GRPCRouteRule defines a single gRPC routing rule.
type GRPCRouteRule struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Matchers for this rule.
	Matches []*GRPCRouteMatch `protobuf:"bytes,1,rep,name=matches,proto3" json:"matches,omitempty"`
	// Backend references for this rule.
	Backends      []*Backend `protobuf:"bytes,2,rep,name=backends,proto3" json:"backends,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GRPCRouteRule) Reset() {
	*x = GRPCRouteRule{}
	mi := &file_routing_v1_routing_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GRPCRouteRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GRPCRouteRule) ProtoMessage() {}

func (x *GRPCRouteRule) ProtoReflect() protoreflect.Message {
	mi := &file_routing_v1_routing_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GRPCRouteRule.ProtoReflect.Descriptor instead.
func (*GRPCRouteRule) Descriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{13}
}

func (x *GRPCRouteRule) GetMatches() []*GRPCRouteMatch {
	if x != nil {
		return x.Matches
	}
	return nil
}

func (x *GRPCRouteRule) GetBackends() []*Backend {
	if x != nil {
		return x.Backends
	}
	return nil
}

// GRPCRouteMatch defines conditions for matching a gRPC request.
type GRPCRouteMatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// gRPC service name to match.
	Method *GRPCMethodMatch `protobuf:"bytes,1,opt,name=method,proto3" json:"method,omitempty"`
	// Header match conditions.
	Headers       []*HeaderMatch `protobuf:"bytes,2,rep,name=headers,proto3" json:"headers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GRPCRouteMatch) Reset() {
	*x = GRPCRouteMatch{}
	mi := &file_routing_v1_routing_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GRPCRouteMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GRPCRouteMatch) ProtoMessage() {}

func (x *GRPCRouteMatch) ProtoReflect() protoreflect.Message {
	mi := &file_routing_v1_routing_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GRPCRouteMatch.ProtoReflect.Descriptor instead.
func (*GRPCRouteMatch) Descriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{14}
}

func (x *GRPCRouteMatch) GetMethod() *GRPCMethodMatch {
	if x != nil {
		return x.Method
	}
	return nil
}

func (x *GRPCRouteMatch) GetHeaders() []*HeaderMatch {
	if x != nil {
		return x.Headers
	}
	return nil
}

// GRPCMethodMatch defines how to match gRPC service/method.
type GRPCMethodMatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Type of method match.
	Type GRPCMethodMatchType `protobuf:"varint,1,opt,name=type,proto3,enum=routing.v1.GRPCMethodMatchType" json:"type,omitempty"`
	// Service name (e.g., "example.MyService").
	Service string `protobuf:"bytes,2,opt,name=service,proto3" json:"service,omitempty"`
	// Method name (e.g., "DoSomething").
	Method        string `protobuf:"bytes,3,opt,name=method,proto3" json:"method,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GRPCMethodMatch) Reset() {
	*x = GRPCMethodMatch{}
	mi := &file_routing_v1_routing_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GRPCMethodMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GRPCMethodMatch) ProtoMessage() {}

func (x *GRPCMethodMatch) ProtoReflect() protoreflect.Message {
	mi := &file_routing_v1_routing_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GRPCMethodMatch.ProtoReflect.Descriptor instead.
func (*GRPCMethodMatch) Descriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{15}
}

func (x *GRPCMethodMatch) GetType() GRPCMethodMatchType {
	if x != nil {
		return x.Type
	}
	return GRPCMethodMatchType_GRPC_METHOD_MATCH_TYPE_UNSPECIFIED
}

func (x *GRPCMethodMatch) GetService() string {
	if x != nil {
		return x.Service
	}
	return ""
}

func (x *GRPCMethodMatch) GetMethod() string {
	if x != nil {
		return x.Method
	}
	return ""
}

// Backend defines a backend service endpoint.
type Backend struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Backend address (host:port).
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Weight for load balancing (1-100).
	Weight uint32 `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
	// Protocol to use for this backend.
	Protocol      BackendProtocol `protobuf:"varint,3,opt,name=protocol,proto3,enum=routing.v1.BackendProtocol" json:"protocol,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Backend) Reset() {
	*x = Backend{}
	mi := &file_routing_v1_routing_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Backend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backend) ProtoMessage() {}

func (x *Backend) ProtoReflect() protoreflect.Message {
	mi := &file_routing_v1_routing_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backend.ProtoReflect.Descriptor instead.
func (*Backend) Descriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{16}
}

func (x *Backend) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *Backend) GetWeight() uint32 {
	if x != nil {
		return x.Weight
	}
	return 0
}

func (x *Backend) GetProtocol() BackendProtocol {
	if x != nil {
		return x.Protocol
	}
	return BackendProtocol_BACKEND_PROTOCOL_UNSPECIFIED
}

// RetryConfig defines retry behavior for failed requests.
type RetryConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Number of retry attempts.
	Attempts uint32 `protobuf:"varint,1,opt,name=attempts,proto3" json:"attempts,omitempty"`
	// Backoff duration between retries in milliseconds.
	BackoffMs uint64 `protobuf:"varint,2,opt,name=backoff_ms,json=backoffMs,proto3" json:"backoff_ms,omitempty"`
	// HTTP status codes that trigger a retry.
	RetryOnStatusCodes []uint32 `protobuf:"varint,3,rep,packed,name=retry_on_status_codes,json=retryOnStatusCodes,proto3" json:"retry_on_status_codes,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *RetryConfig) Reset() {
	*x = RetryConfig{}
	mi := &file_routing_v1_routing_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RetryConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RetryConfig) ProtoMessage() {}

func (x *RetryConfig) ProtoReflect() protoreflect.Message {
	mi := &file_routing_v1_routing_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RetryConfig.ProtoReflect.Descriptor instead.
func (*RetryConfig) Descriptor() ([]byte, []int) {
	return file_routing_v1_routing_proto_rawDescGZIP(), []int{17}
}

func (x *RetryConfig) GetAttempts() uint32 {
	if x != nil {
		return x.Attempts
	}
	return 0
}

func (x *RetryConfig) GetBackoffMs() uint64 {
	if x != nil {
		return x.BackoffMs
	}
	return 0
}

func (x *RetryConfig) GetRetryOnStatusCodes() []uint32 {
	if x != nil {
		return x.RetryOnStatusCodes
	}
	return nil
}

var File_routing_v1_routing_proto protoreflect.FileDescriptor

const file_routing_v1_routing_proto_rawDesc = "" +
	"\n" +
	"\x18routing/v1/routing.proto\x12\n" +
	"routing.v1\"\x9f\x01\n" +
	"\x13UpdateRoutesRequest\x126\n" +
	"\vhttp_routes\x18\x01 \x03(\v2\x15.routing.v1.HTTPRouteR\n" +
	"httpRoutes\x126\n" +
	"\vgrpc_routes\x18\x02 \x03(\v2\x15.routing.v1.GRPCRouteR\n" +
	"grpcRoutes\x12\x18\n" +
	"\aversion\x18\x03 \x01(\x04R\aversion\"\xc3\x01\n" +
	"\x14UpdateRoutesResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12'\n" +
	"\x0fapplied_version\x18\x03 \x01(\x04R\x0eappliedVersion\x12(\n" +
	"\x10http_route_count\x18\x04 \x01(\rR\x0ehttpRouteCount\x12(\n" +
	"\x10grpc_route_count\x18\x05 \x01(\rR\x0egrpcRouteCount\"\x12\n" +
	"\x10GetRoutesRequest\"\x9d\x01\n" +
	"\x11GetRoutesResponse\x126\n" +
	"\vhttp_routes\x18\x01 \x03(\v2\x15.routing.v1.HTTPRouteR\n" +
	"httpRoutes\x126\n" +
	"\vgrpc_routes\x18\x02 \x03(\v2\x15.routing.v1.GRPCRouteR\n" +
	"grpcRoutes\x12\x18\n" +
	"\aversion\x18\x03 \x01(\x04R\aversion\"\x0f\n" +
	"\rHealthRequest\"\x98\x01\n" +
	"\x0eHealthResponse\x12\x18\n" +
	"\ahealthy\x18\x01 \x01(\bR\ahealthy\x12\x16\n" +
	"\x06status\x18\x02 \x01(\tR\x06status\x12-\n" +
	"\x12active_connections\x18\x03 \x01(\x04R\x11activeConnections\x12%\n" +
	"\x0econfig_version\x18\x04 \x01(\x04R\rconfigVersion\"j\n" +
	"\tHTTPRoute\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1c\n" +
	"\thostnames\x18\x02 \x03(\tR\thostnames\x12/\n" +
	"\x05rules\x18\x03 \x03(\v2\x19.routing.v1.HTTPRouteRuleR\x05rules\"\xc4\x01\n" +
	"\rHTTPRouteRule\x124\n" +
	"\amatches\x18\x01 \x03(\v2\x1a.routing.v1.HTTPRouteMatchR\amatches\x12/\n" +
	"\bbackends\x18\x02 \x03(\v2\x13.routing.v1.BackendR\bbackends\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x03 \x01(\x04R\ttimeoutMs\x12-\n" +
	"\x05retry\x18\x04 \x01(\v2\x17.routing.v1.RetryConfigR\x05retry\"\xc6\x01\n" +
	"\x0eHTTPRouteMatch\x12)\n" +
	"\x04path\x18\x01 \x01(\v2\x15.routing.v1.PathMatchR\x04path\x121\n" +
	"\aheaders\x18\x02 \x03(\v2\x17.routing.v1.HeaderMatchR\aheaders\x12>\n" +
	"\fquery_params\x18\x03 \x03(\v2\x1b.routing.v1.QueryParamMatchR\vqueryParams\x12\x16\n" +
	"\x06method\x18\x04 \x01(\tR\x06method\"P\n" +
	"\tPathMatch\x12-\n" +
	"\x04type\x18\x01 \x01(\x0e2\x19.routing.v1.PathMatchTypeR\x04type\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\"h\n" +
	"\vHeaderMatch\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\x12/\n" +
	"\x04type\x18\x03 \x01(\x0e2\x1b.routing.v1.HeaderMatchTypeR\x04type\"p\n" +
	"\x0fQueryParamMatch\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\x123\n" +
	"\x04type\x18\x03 \x01(\x0e2\x1f.routing.v1.QueryParamMatchTypeR\x04type\"j\n" +
	"\tGRPCRoute\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1c\n" +
	"\thostnames\x18\x02 \x03(\tR\thostnames\x12/\n" +
	"\x05rules\x18\x03 \x03(\v2\x19.routing.v1.GRPCRouteRuleR\x05rules\"v\n" +
	"\rGRPCRouteRule\x124\n" +
	"\amatches\x18\x01 \x03(\v2\x1a.routing.v1.GRPCRouteMatchR\amatches\x12/\n" +
	"\bbackends\x18\x02 \x03(\v2\x13.routing.v1.BackendR\bbackends\"x\n" +
	"\x0eGRPCRouteMatch\x123\n" +
	"\x06method\x18\x01 \x01(\v2\x1b.routing.v1.GRPCMethodMatchR\x06method\x121\n" +
	"\aheaders\x18\x02 \x03(\v2\x17.routing.v1.HeaderMatchR\aheaders\"x\n" +
	"\x0fGRPCMethodMatch\x123\n" +
	"\x04type\x18\x01 \x01(\x0e2\x1f.routing.v1.GRPCMethodMatchTypeR\x04type\x12\x18\n" +
	"\aservice\x18\x02 \x01(\tR\aservice\x12\x16\n" +
	"\x06method\x18\x03 \x01(\tR\x06method\"t\n" +
	"\aBackend\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x12\x16\n" +
	"\x06weight\x18\x02 \x01(\rR\x06weight\x127\n" +
	"\bprotocol\x18\x03 \x01(\x0e2\x1b.routing.v1.BackendProtocolR\bprotocol\"{\n" +
	"\vRetryConfig\x12\x1a\n" +
	"\battempts\x18\x01 \x01(\rR\battempts\x12\x1d\n" +
	"\n" +
	"backoff_ms\x18\x02 \x01(\x04R\tbackoffMs\x121\n" +
	"\x15retry_on_status_codes\x18\x03 \x03(\rR\x12retryOnStatusCodes*\x82\x01\n" +
	"\rPathMatchType\x12\x1f\n" +
	"\x1bPATH_MATCH_TYPE_UNSPECIFIED\x10\x00\x12\x19\n" +
	"\x15PATH_MATCH_TYPE_EXACT\x10\x01\x12\x1a\n" +
	"\x16PATH_MATCH_TYPE_PREFIX\x10\x02\x12\x19\n" +
	"\x15PATH_MATCH_TYPE_REGEX\x10\x03*n\n" +
	"\x0fHeaderMatchType\x12!\n" +
	"\x1dHEADER_MATCH_TYPE_UNSPECIFIED\x10\x00\x12\x1b\n" +
	"\x17HEADER_MATCH_TYPE_EXACT\x10\x01\x12\x1b\n" +
	"\x17HEADER_MATCH_TYPE_REGEX\x10\x02*\x81\x01\n" +
	"\x13QueryParamMatchType\x12&\n" +
	"\"QUERY_PARAM_MATCH_TYPE_UNSPECIFIED\x10\x00\x12 \n" +
	"\x1cQUERY_PARAM_MATCH_TYPE_EXACT\x10\x01\x12 \n" +
	"\x1cQUERY_PARAM_MATCH_TYPE_REGEX\x10\x02*\x81\x01\n" +
	"\x13GRPCMethodMatchType\x12&\n" +
	"\"GRPC_METHOD_MATCH_TYPE_UNSPECIFIED\x10\x00\x12 \n" +
	"\x1cGRPC_METHOD_MATCH_TYPE_EXACT\x10\x01\x12 \n" +
	"\x1cGRPC_METHOD_MATCH_TYPE_REGEX\x10\x02*\x9d\x01\n" +
	"\x0fBackendProtocol\x12 \n" +
	"\x1cBACKEND_PROTOCOL_UNSPECIFIED\x10\x00\x12\x19\n" +
	"\x15BACKEND_PROTOCOL_HTTP\x10\x01\x12\x1a\n" +
	"\x16BACKEND_PROTOCOL_HTTPS\x10\x02\x12\x18\n" +
	"\x14BACKEND_PROTOCOL_H2C\x10\x03\x12\x17\n" +
	"\x13BACKEND_PROTOCOL_H2\x10\x042\xee\x01\n" +
	"\x0eRoutingService\x12Q\n" +
	"\fUpdateRoutes\x12\x1f.routing.v1.UpdateRoutesRequest\x1a .routing.v1.UpdateRoutesResponse\x12H\n" +
	"\tGetRoutes\x12\x1c.routing.v1.GetRoutesRequest\x1a\x1d.routing.v1.GetRoutesResponse\x12?\n" +
	"\x06Health\x12\x19.routing.v1.HealthRequest\x1a\x1a.routing.v1.HealthResponseB\xb3\x01\n" +
	"\x0ecom.routing.v1B\fRoutingProtoP\x01ZJgithub.com/lexfrei/pingora-gateway-controller/pkg/api/routing/v1;routingv1\xa2\x02\x03RXX\xaa\x02\n" +
	"Routing.V1\xca\x02\n" +
	"Routing\\V1\xe2\x02\x16Routing\\V1\\GPBMetadata\xea\x02\vRouting::V1b\x06proto3"

var (
	file_routing_v1_routing_proto_rawDescOnce sync.Once
	file_routing_v1_routing_proto_rawDescData []byte
)

func file_routing_v1_routing_proto_rawDescGZIP() []byte {
	file_routing_v1_routing_proto_rawDescOnce.Do(func() {
		file_routing_v1_routing_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_routing_v1_routing_proto_rawDesc), len(file_routing_v1_routing_proto_rawDesc)))
	})
	return file_routing_v1_routing_proto_rawDescData
}

var file_routing_v1_routing_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_routing_v1_routing_proto_msgTypes = make([]protoimpl.MessageInfo, 18)
var file_routing_v1_routing_proto_goTypes = []any{
	(PathMatchType)(0),           // 0: routing.v1.PathMatchType
	(HeaderMatchType)(0),         // 1: routing.v1.HeaderMatchType
	(QueryParamMatchType)(0),     // 2: routing.v1.QueryParamMatchType
	(GRPCMethodMatchType)(0),     // 3: routing.v1.GRPCMethodMatchType
	(BackendProtocol)(0),         // 4: routing.v1.BackendProtocol
	(*UpdateRoutesRequest)(nil),  // 5: routing.v1.UpdateRoutesRequest
	(*UpdateRoutesResponse)(nil), // 6: routing.v1.UpdateRoutesResponse
	(*GetRoutesRequest)(nil),     // 7: routing.v1.GetRoutesRequest
	(*GetRoutesResponse)(nil),    // 8: routing.v1.GetRoutesResponse
	(*HealthRequest)(nil),        // 9: routing.v1.HealthRequest
	(*HealthResponse)(nil),       // 10: routing.v1.HealthResponse
	(*HTTPRoute)(nil),            // 11: routing.v1.HTTPRoute
	(*HTTPRouteRule)(nil),        // 12: routing.v1.HTTPRouteRule
	(*HTTPRouteMatch)(nil),       // 13: routing.v1.HTTPRouteMatch
	(*PathMatch)(nil),            // 14: routing.v1.PathMatch
	(*HeaderMatch)(nil),          // 15: routing.v1.HeaderMatch
	(*QueryParamMatch)(nil),      // 16: routing.v1.QueryParamMatch
	(*GRPCRoute)(nil),            // 17: routing.v1.GRPCRoute
	(*GRPCRouteRule)(nil),        // 18: routing.v1.GRPCRouteRule
	(*GRPCRouteMatch)(nil),       // 19: routing.v1.GRPCRouteMatch
	(*GRPCMethodMatch)(nil),      // 20: routing.v1.GRPCMethodMatch
	(*Backend)(nil),              // 21: routing.v1.Backend
	(*RetryConfig)(nil),          // 22: routing.v1.RetryConfig
}
var file_routing_v1_routing_proto_depIdxs = []int32{
	11, // 0: routing.v1.UpdateRoutesRequest.http_routes:type_name -> routing.v1.HTTPRoute
	17, // 1: routing.v1.UpdateRoutesRequest.grpc_routes:type_name -> routing.v1.GRPCRoute
	11, // 2: routing.v1.GetRoutesResponse.http_routes:type_name -> routing.v1.HTTPRoute
	17, // 3: routing.v1.GetRoutesResponse.grpc_routes:type_name -> routing.v1.GRPCRoute
	12, // 4: routing.v1.HTTPRoute.rules:type_name -> routing.v1.HTTPRouteRule
	13, // 5: routing.v1.HTTPRouteRule.matches:type_name -> routing.v1.HTTPRouteMatch
	21, // 6: routing.v1.HTTPRouteRule.backends:type_name -> routing.v1.Backend
	22, // 7: routing.v1.HTTPRouteRule.retry:type_name -> routing.v1.RetryConfig
	14, // 8: routing.v1.HTTPRouteMatch.path:type_name -> routing.v1.PathMatch
	15, // 9: routing.v1.HTTPRouteMatch.headers:type_name -> routing.v1.HeaderMatch
	16, // 10: routing.v1.HTTPRouteMatch.query_params:type_name -> routing.v1.QueryParamMatch
	0,  // 11: routing.v1.PathMatch.type:type_name -> routing.v1.PathMatchType
	1,  // 12: routing.v1.HeaderMatch.type:type_name -> routing.v1.HeaderMatchType
	2,  // 13: routing.v1.QueryParamMatch.type:type_name -> routing.v1.QueryParamMatchType
	18, // 14: routing.v1.GRPCRoute.rules:type_name -> routing.v1.GRPCRouteRule
	19, // 15: routing.v1.GRPCRouteRule.matches:type_name -> routing.v1.GRPCRouteMatch
	21, // 16: routing.v1.GRPCRouteRule.backends:type_name -> routing.v1.Backend
	20, // 17: routing.v1.GRPCRouteMatch.method:type_name -> routing.v1.GRPCMethodMatch
	15, // 18: routing.v1.GRPCRouteMatch.headers:type_name -> routing.v1.HeaderMatch
	3,  // 19: routing.v1.GRPCMethodMatch.type:type_name -> routing.v1.GRPCMethodMatchType
	4,  // 20: routing.v1.Backend.protocol:type_name -> routing.v1.BackendProtocol
	5,  // 21: routing.v1.RoutingService.UpdateRoutes:input_type -> routing.v1.UpdateRoutesRequest
	7,  // 22: routing.v1.RoutingService.GetRoutes:input_type -> routing.v1.GetRoutesRequest
	9,  // 23: routing.v1.RoutingService.Health:input_type -> routing.v1.HealthRequest
	6,  // 24: routing.v1.RoutingService.UpdateRoutes:output_type -> routing.v1.UpdateRoutesResponse
	8,  // 25: routing.v1.RoutingService.GetRoutes:output_type -> routing.v1.GetRoutesResponse
	10, // 26: routing.v1.RoutingService.Health:output_type -> routing.v1.HealthResponse
	24, // [24:27] is the sub-list for method output_type
	21, // [21:24] is the sub-list for method input_type
	21, // [21:21] is the sub-list for extension type_name
	21, // [21:21] is the sub-list for extension extendee
	0,  // [0:21] is the sub-list for field type_name
}

func init() { file_routing_v1_routing_proto_init() }
func file_routing_v1_routing_proto_init() {
	if File_routing_v1_routing_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_routing_v1_routing_proto_rawDesc), len(file_routing_v1_routing_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   18,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_routing_v1_routing_proto_goTypes,
		DependencyIndexes: file_routing_v1_routing_proto_depIdxs,
		EnumInfos:         file_routing_v1_routing_proto_enumTypes,
		MessageInfos:      file_routing_v1_routing_proto_msgTypes,
	}.Build()
	File_routing_v1_routing_proto = out.File
	file_routing_v1_routing_proto_goTypes = nil
	file_routing_v1_routing_proto_depIdxs = nil
}
